---
title: 数据结构系列：图
date: 2016-12-17 23:12:01
tags:
- C++
- algorithm
categories: ACM
description: 小萌花的数据结构作业代码
---

作者：saferman 的女票票

这部分内容，是我的女票编写，记录其完成的数据结构课程作业的代码，涵盖了其所接触的图论中很重要的知识

### 数据结构知识点

今天我学习了 ...

辣鸡百度代码功能都不完整 ...

写作业真累 ...

### 实现的功能

想实现的功能都有

我真是个小机灵鬼

- 图的初始化和创建
- 图的深度优先遍历和广度优先遍历
- 图的 Dijastra 算法 和 floyd 算法实现

### 代码

```c++
#include <stdio.h>
#define MaxVertexNum  100   // 顶点数目最大值
typedef char VertexType;    // 顶点的数据类型
typedef int EdgeType;       // 带权图中边上权值的数据类型
 
typedef struct{
	VertexType Vex[MaxVertexNum];                 // 顶点表
	EdgeType Edge[MaxVertexNum][MaxVertexNum];    // 邻接矩阵，边表
	int vexnum, edgenum;                          // 图的顶点数和弧数
}MGraph;
 
void create_Graph(MGraph *G){           // 创建无向图 
	int i, j;
	int start, end;                     // 边的起点序号、终点序号
	int numV, numE;
	int w;                              // 边上的权值
	printf(" 请输入所创建无向图的顶点数和边数 (用空格隔开):");
	scanf("%d %d", &numV, &numE);
	G->vexnum=numV;
	G->edgenum=numE;
	printf("\n");
	for (i = 0; i < G->vexnum; i++){     // 图的初始化
		for (j = 0; j < G->vexnum; j++){
			if (i == j)
				G->Edge[i][j] = 0;
			else
				G->Edge[i][j] = 32767;
		}
	}
	
	for (i = 0; i < G->vexnum; i++){     // 顶点信息存入顶点表
		printf(" 请输入第 %d 个顶点的信息 :",i+1);
		scanf("%d", &G->Vex[i]);
	}
	printf("\n");
	
	for (i = 0; i < G->edgenum; i++){    // 输入无向图边的信息
		printf(" 请输入边的起点序号，终点序号，权值 (用空格隔开)：");
		scanf("%d%d%d", &start, &end, &w);
		G->Edge[start -1][end -1] = w;
		G->Edge[end - 1][start - 1] = w;   
	}
}
 
void print_Matrix(MGraph G){               // 打印出邻接矩阵
	int i, j;
	printf("\n 图的顶点为 :");
	for (i = 0; i < G.vexnum; i++)
		printf("%4d", G.Vex[i]);
	printf("\n 输出邻接矩阵 :\n");
	for (i = 0; i < G.vexnum; i++){
		for (j = 0; j < G.vexnum; j++){
			if (G.Edge[i][j] == 32767)
				printf("\t%4 s", "∞");
			else
				printf("\t%4d", G.Edge[i][j]);
		}
		printf("\n");
	}	
}
 
int visitDFS[MaxVertexNum];

void DFS(MGraph G,int i){
	int j;
	visitDFS[i] = 1;
	printf("%d ", G.Vex[i]);
	for (j = 0; j < G.vexnum; j++){
		if (G.Edge[i][j] != 32767 && !visitDFS[j])
			DFS(G, j);
	}
}
 
void DFSTraverse(MGraph G){                // 深度优先遍历 
	int i;
	for (i = 0; i < G.vexnum; i++){
		visitDFS[i] = 0;
	}
	for (i = 0; i < G.vexnum; i++){
		if (!visitDFS[i])
			DFS(G, i);
	}
}
 
typedef struct
{
	int data[MaxVertexNum];
	int front, rear;
}Queue;

void InitQueue(Queue *Q){       // 初始化队列 
	Q->front = Q->rear = 0;
}
 
int IsEmpty(Queue *Q){          // 判断队空
	if (Q->front == Q->rear)
		return 1;
	else
		return 0;
}
 
void EnQueue(Queue *Q,int e){    // 入队
	if ((Q->rear + 1) % MaxVertexNum == Q->front)
		return;
	else{
		Q->data[Q->rear] = e;
		Q->rear = (Q->rear + 1) % MaxVertexNum;
	}
}

void DeQueue(Queue *Q,int *e){   // 出队
	if (Q->rear == Q->front)
		return;
	*e = Q->data[Q->front];
	Q->front = (Q->front + 1) % MaxVertexNum;
}

int visitBFS[MaxVertexNum];

void BFS(MGraph G){               // 广度优先遍历
	int i, j;
	Queue Q;
	for (i = 0; i < G.vexnum; i++)
		visitBFS[MaxVertexNum] = 0;
	InitQueue(&Q);
	for (i = 0; i < G.vexnum; i++){
		if (!visitBFS[i]){
			visitBFS[i] = 1;
			printf("%d ", G.Vex[i]);
			EnQueue(&Q, i);
 			while (!IsEmpty(&Q)){
				DeQueue(&Q, &i);
				for (j = 0; j < G.vexnum; j++){
					if (!visitBFS[j] && G.Edge[i][j] != 32767){
						visitBFS[j] = 1;
						printf("%d ", G.Vex[j]);
						EnQueue(&Q, j);
					}
				}
			}
		}
	}
}
 
void dijkstra(MGraph *g, int source){       // 求最短路径 
    int N=g->vexnum;
	int dis[N];
    int book [N];
    int min,u;
    for(int k=0;k<N;k++){                   // 初始化 dis 与 book 向量
        dis[k]=g->Edge[source][k];
        book[k] = 0 ;
    }
    book[source] = 1;
    
    for(int i=0;i<N;i++){
        min = 32767;
        for(int j=0;j<N;j++){
            if(book[j]==0 && dis[j]<min){
                min = dis[j];
                u=j;
            }
        }
        
        book[u]=1;
        for(int v=0;v<N;v++){
            if(g->Edge[u][v]<32767){
                if(dis[v]>dis[u]+g->Edge[u][v])
                dis[v]=dis[u]+g->Edge[u][v];
            }
        }
    } 
    for(int k=0;k<N;k++){
    	printf(" 从第 1 个顶点到第 %d 个顶点的最短路径为：%d\n",k+1,dis[k]);
	}
}

void floyd(MGraph *g){              //floyd 算法求最短路径 
    int i, j, k;
    int N = g->vexnum;
    for (k = 0; k < N; k++){
        for (i = 0; i < N; i++){
            for (j = 0; j < N; j++){
                if (g->Edge[i][k] < 32767&&g->Edge[k][j]< 32767&&g->Edge[i][j]>g->Edge[i][k] + g->Edge[k][j]){
                    g->Edge[i][j]=g->Edge[i][k] + g->Edge[k][j];
                }
            }
        }
    }
    for (i=0;i<N;i++){
    	for(j=0;j<N;j++){
    		printf("%4d   ",g->Edge[i][j]);
    		}
    	printf("\n"); 
	} 
}

int main(){
	MGraph G;
	create_Graph(&G);
	print_Matrix(G);
	printf(" 深度优先：\n");
	DFSTraverse(G);
	printf("\n 广度优先：\n"); 
	BFS(G);
	int source=0; 
	printf("\n 第一个点到所有点的最短路径 \n"); 
	dijkstra(&G, source);
	printf("\nFLOYD 算法求最短路径 \n");
	floyd(&G);
	return 0;
}
```

