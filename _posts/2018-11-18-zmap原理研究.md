---
title: zmap原理研究
date: 2018-11-18 12:36
tags:
- research
- scan
categories: research
description: 研究一下这种扫描技术，为什么他能这么快？
---
ZMap是一款扫描软件，由Durumeric领导密歇根大学研究团队开发，这种工具能令一台普通的服务器在短短45分钟时间里扫描IPv4网络空间上的每一个地址，叹为观止！扫描效率比Nmap强多了。

刚好近期在研究IPv6扫描，也就产生了想深入研究这款工具的扫描原理想法，也就有了这篇文章。下面我将按照《ZMap: Fast Internet-wide Scanning and Its Security Applications》这篇论文探究一下ZMap的扫描原理，也作为论文学习的笔记。

### ZMap性能

按照论文的说法，这款工具有下面二方面的性能

- 指定一个端口，ZMap只需要45分钟就可以在一台普通的主机上对整个IPv4地址空间的完成扫描
- 在默认的配置下，ZMap比Nmap扫描整个IPv6地址空间快了1300倍

### ZMap架构新的特点

首先来看看ZMap有哪些新的特点帮助它实现高性能的扫描：

##### （1）Optimized probe

为了避免扫描发送的探针对发送方的网络和目的网络造成压力从而导致速率下降等不好的结果出现，本文的探针采用随机探针生成技术并且广泛散发的方法，即按照随机的顺序对全网目的地址进行扫描，相邻发送的探针数据包不一定被送至相同的网络。同时ZMap按照发送方NIC最大速率发送探针，并且跳过TCP/IP栈直接生成链路层的帧。

##### （2）No per-connection state

Nmap会对每一个连接维护一些状态来帮助程序确认哪些主机被扫描过以及是否需要重新发送。与之不同，ZMap不保存任何连接的这些状态。首先在解决如何不重复不遗漏扫描全部需要扫描的主机问题上，ZMap主要使用了周期乘法生成地址的随机全排列。此外，ZMap接受的响应数据包携带有一些状态字段，程序会从中提取尽可能多的有用信息帮助ZMap得到扫描结果。为了将探针导致的响应数据包从网络中的其他数据包识别分离出来，ZMap会重载每一个发送的数据包中未被使用的值来做一些标识，这一点有点像SYN cookies。

##### （3）No retransmission

ZMap总是针对每一个目标发送相同且固定的探针数据包（默认一个），并且不会像Nmap那样在超时后重新发送相同探针数据包。也就是说ZMap不会重新发送任何数据包，主要是避免维护一些不必要的状态。放心，文章实验证明了即使在最大的扫描速率下只对每一个目标地址发送一个探针数据包也可以有效的扫描完98%的网络空间。

### 架构

![1542464237222](https://saferman.github.io/assets/img/zmap_imgs/ZMap_architecture.png)

这部分介绍一下ZMap的架构和整体的设计思想：

- 蓝色Packet Generation和Response Interpretation： 指出生成和处理多种探针数据包，包括TCP SYN扫描的和ICMP echo扫描的
- 红色Output Handler：输出结果并且允许用户处理这些结果
- 设计思想：最重要的架构特点在于扫描过程和接受处理过程是在不同的线程完成的，彼此独立并且连续的进行

整个系统大约用了8900行C代码完成。下面我着重针对ZMap三个主要的点展开深入的讨论。

### Addressing Probes

首先先来看一个数学例子，如果我们期望遍历1-6整数，但是又不想按照顺序去遍历，想使用随机的方法遍历这些整数，一种方法如图所示，即整数模n乘法群（**multiplicative group of integers modulo n** ）。 相关参考文献：[维基百科-整数模n乘法群](https://zh.wikipedia.org/zh-hans/%E6%95%B4%E6%95%B0%E6%A8%A1n%E4%B9%98%E6%B3%95%E7%BE%A4)

![1542509769115](https://saferman.github.io/assets/img/zmap_imgs/multiplicative_group_.png)

可以看到只要我们选定一个稍微大于需要遍历的序列最大数的奇质数n（论文用符号p表示，此处为7），那么再选定一个需要遍历的数列其中一个元素primitive root（此处为5，选择其他的比如3也可以），通过相乘取余数可以生成数列的一个全排列。

应用在IPv4地址中，我们可以将128bit的IPv4地址空间看成一个1~2^32的整数集合（128位的二进制转换为10进制数），每一个整数对应IPv4的一个地址（0.0.0.0地址对应的整数为0，没有扫描的意义故排除）。然后论文选择了一个稍微大一些奇质数2^32+15作为p，选择3作为primitive root。这样可以用相同的数学原理得到1~2^32整数的全排列，每一个整数转换位128位二进制即可得到IPv4地址。

### Packet Transmission and Receipt

ZMap被设计尽可能使用源主机的CPU和NIC能支持的最大发包速率去发送探针数据包(probe)。程序直接在以太网层（即链路层，以太网协议是链路层很重要的一个协议）发送raw packet，避免过多的内核层面的操作包括路由表查询、arp缓存查询和*Netfilter* 检验。这样链路层头部，包括校验码在整个扫描过程都不会变的，在内核中也不会建立任何TCP session。

ZMap的接受模块仍然使用libpcap，虽然这个库很多时候会成为性能的瓶颈，但是考虑到响应的数据包速率不会有发送的那么快，在论文的测试中也验证了这一个观点，所以使用libpcap是可行的。

在接收到数据包后，通过源端口和目的端口直接跳过那些明显不是响应我们扫描的数据，将剩下的数据包传送到probe module进一步解析。由于发送和接受主线程是独立的，在发送结束后接受线程仍然额外持续8秒。

### Probe Modules

如果使用TCP 端口扫描，采用的技术都是SYN scanning可以根据响应的数据包判断是unreachable、close还是open（对应三种情况：无响应，响应RST以及响应 SYN-ACK）。

该模块一个很重要的任务就是识别那些响应数据包是针对我们的探针数据包响应的。按照原文的说法解决方法就是：

> Probe modules perform this validation by encoding host- and scan-invocation–specific data into mutable fields of each probe packet, utilizing fields that will have recognizable effects on fields of the corresponding response packets in a manner similar to SYN cookies.

具体哪些发送的数据包字段会在响应的时候携带发送字段的信息：在我们的TCP扫描技术中，我们采用源端口和序列数字；在ICMP扫描技术中，我们使用ICMP identifier和序列数字(sequence number)。

这种验证技术很类似SYN Cookie，这种技术主要使用与防范SYN Flood攻击的（SYN Cookie[原理可以参考https://zh.wikipedia.org/wiki/SYN_cookie](https://zh.wikipedia.org/wiki/SYN_cookie)和 [SYN cookies机制下连接的建立](https://blog.csdn.net/justlinux2010/article/details/12619761)）

> 在syn到来的时候， 服务端并不会为这个syn包分配资源， 免得受骗上当。只有当服务端自己的syn/ack收到客户端的ack后， 才会真正分配资源， 此时才完成正常的连接。 由此可见， 此时syn flood失效。 

同时这一部分的ZMap作者参考了《UMAC: Fast and secure message authentication》文献，也值得去阅读一边进一步了解识别响应数据包的工作原理。特别说明这部分论文提到的MAC不是指物理地址，而是消息摘要的意思。

### 和Nmap的性能比较

![1542515605468](https://saferman.github.io/assets/img/zmap_imgs/ZMapVSnmap.png)

ZMap can scan more than 1300 times faster than the most aggressive Nmap default configuration (“insane”)s

Now possible to scan the entire IPv4 address space from one host in under 45 minutes with 98% coverage