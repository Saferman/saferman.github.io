---
title: PHP Source Research for CTF
date: 2018-10-19 16:05
tags:
- CTF
- Web
- PHP
categories: CTF
description: 为了更加全面的吃透 PHP 特性，我决定更加深入的研究 PHP 常见函数底层代码实现
---

作为一名不擅长开发 PHP 的 CTFer，近期从各大 CTF 的 PHP 源码审计收获了很多，比如 hacklu 比赛以及最近的研究的 [php 代码审计分段讲解](https://github.com/bowu678/php_bugs) 项目。虽然通过专注的解题最终能够解决这类题目的，但是通常需要花费很多时间在查阅文献和测试上面。相信有很多 CTF 选手对此也是深有体会。

究其根本原理，我们在看到一个 PHP 函数的时候，很难准确快速的说出和这个函数的全部特性（哪些字符可以绕过，怎么处理非预期的数据类型等等）。比如第一次接触下面的这段判断语句，你能快速告诉我怎么才能让 if 里的判断语句为假吗？

```php
if($req['number']!=strval(intval($req['number']))) {
     $info = "You are stupid!";
}else{
     $info = "You are clever!";
}
echo $info;
```

又或者今年的 hacklu 一段代码，if 里的判断逻辑怎么才能为 True？第一次接触这类问题，你花了多少时间想到？

```php
$cc = 1337;$bb = 42;
@$cc = $_GET['cc'];
if(substr($cc, $bb) === sha1($cc)){
    ......
}
```

还有如果 $bb 可控，为什么下述代码会出现恶意代买执行漏洞？

```php
assert("$bb == $cc");
```



所以很有必要详细阅读一遍 PHP 常见函数的底层 C 代码实现原理，在自己的脑袋里对这个函数形成一个**清晰的实现逻辑 **，这样这些函数相关的题目无论怎么变化都能够从容应对！

当然这也是为了回归**最本质的安全研究方法 **：** 代码审计 **。也许通过阅读这些代码还能发现意外的收获！

针对每一个 PHP 函数的源码阅读，我会做这些事情：

- 给出这些 PHPH 函数的底层代码，重要的会附上注释
- 中文描述其完整逻辑流，黑色加粗
- 总结这次源码阅读没有深入的地方
- 给出测试这个函数特性的 PHP 代码

本文持续更新，目前阅读过的 PHP 函数包括：is_numeric、intval、strval

### PHP 底层源码阅读方法

讲解一下我的 PHP 源码阅读方法：

- 准备工具：Source Insight   下载地址：[https://www.cnblogs.com/dakewei/p/7993613.html](https://www.cnblogs.com/dakewei/p/7993613.html)
- PHP 源码（最新）：[http://php.net/downloads.php](http://php.net/downloads.php)
- 基础知识：C 语言以及 C 语言函数的特性、Ascii 码全部字符

PHP 库函数基本都在 **php-src/ext** 目录下面，一般的函数在 **standard** 目录，当然也有具体的函数库 socket。

查找一个库函数的源码（比如 intval），直接在 SourceInsight 里搜索项目：PHP_FUNCTION(intval)。

### is_numeric

```c
PHP_FUNCTION(is_numeric)
{
	zval *arg;                  // is_numeric 使用的时候传递的

	ZEND_PARSE_PARAMETERS_START(1, 1)
		Z_PARAM_ZVAL(arg)
	ZEND_PARSE_PARAMETERS_END();

	switch (Z_TYPE_P(arg)) {
		case IS_LONG:
		case IS_DOUBLE:
			RETURN_TRUE;
			break;

		case IS_STRING:
			if (is_numeric_string(Z_STRVAL_P(arg), Z_STRLEN_P(arg), NULL, NULL, 0)) {
				RETURN_TRUE;
			} else {
				RETURN_FALSE;
			}
			break;

		default:
			RETURN_FALSE;
			break;
	}
}
```

在这个函数里面主要是根据 is_numeric 传递的参数类型做出了不同的操作：

1.**如果是 long 或 double 类型直接返回逻辑 True**
2.**如果是字符串（CTF 常见的传入格式）会调用 is_numeric_string 判断这个字符串是否是数字 **
3.**其余情况返回 False**


下面我们跟踪 is_numeric_string 函数，调用了 is_numeric_string_ex

```c
static zend_always_inline zend_uchar is_numeric_string(const char *str, size_t length, zend_long *lval, double *dval, int allow_errors) {
    return is_numeric_string_ex(str, length, lval, dval, allow_errors, NULL);
}
```

继续跟踪 is_numeric_string_ex 函数：

```c
static zend_always_inline zend_uchar is_numeric_string_ex(const char *str, size_t length, zend_long *lval, double *dval, int allow_errors, int *oflow_info)
{
	if (*str > '9') {
		return 0;
	}
	return _is_numeric_string_ex(str, length, lval, dval, allow_errors, oflow_info);
}
```

